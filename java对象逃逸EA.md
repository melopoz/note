# 逃逸分析 Escape Analysis  简称 EA

EA允许java编译器在多种情况下优化我们的代码。

https://blog.csdn.net/wolfcode_cn/article/details/83058235

## 对象逃逸 的 三种状态

- 全局级别逃逸 全局逃逸状态

  > 一个对象可能从一个方法或当前线程中逃逸。
  >
  > 1. 如果一个对象被作为方法的返回值，
  >
  > 2. 作为类静态字段 static field
  >
  >    > 所以肯定存在堆内存。
  >
  > 3. 作为类字段 field
  >
  > 4. 重写了finalize()方法
  >
  >    > 这要求这个对象对JVM的finalizer必须是可见的，所以必须分配在堆内存。
  >
  >    > finalize()方法没啥意义，为了方便c/c++程序员适应java的。这里用来举例。
  >
  > 就会被标记为全集逃逸状态。

  **全局逃逸状态的对象一定会放入堆内存中。**

- 参数级别逃逸

  > 一个对象被作为参数传递给了一个方法，这个方法之外的还是无法访问该对象的(对其他线程不可见)，这个对象就会被标记为参数级别逃逸。

- 无逃逸状态

  > 不产生逃逸。

## 推论

- 理论上，无逃逸状态的对象不必须存储在堆空间中，那就是可以直接在栈上分配内存，甚至直接在CPU寄存器中分配空间，效率极高。

- 参数级别逃逸是可能在内存中去掉对象同步锁的，因为该对象不能被其他线程访问到。

  > 同步的代价很大，去掉同步锁可以提高并发性能。

- 无逃逸状态

  > 标量替换：java虚拟机中的原始数据类型(int,long等)都不能在进一步分解，他们就可以成为标量。相对的，如果一个数据可以继续分解，那么他成为聚合量，java中最典型的聚合量就是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个这个对象是可以分解的，那么程序真正执行的时候可能不创建这个对象，而改为直接创建它的若干个被这个方法能够使用到的成员变量来代替。拆散后的变量便可以被单独的分析与优化，可以分别分配在栈帧或者寄存器上，原来的对象就不需要整体被分配在堆中。

## 应用

一个方法中new一个对象并作为返回值return出去的时候，该返回的对象就是全局逃逸状态。

如果在方法的参数中就传入承载计算结果的容器，在把这个方法计算的结果存入该参数，不用设置该大对象为返回值。

> 例如
>
> ```java
> private Object doSomething(Object arg1, Object arg2){
> 	//do something...
> 	Object result = new Object();
> 	return result;
> };
> ```
>
> 改为
>
> ```java
> private void doSomething(Object arg1, Object arg2, Object result){};
> ```

就不会有全局对象逃逸，参数级别逃逸就可能去掉同步锁，可以提高并发性能。

在一个线程中的一串任务中如果都使用这种方式，就可能节省堆空间，降低gc的压力。提高程序的性能。